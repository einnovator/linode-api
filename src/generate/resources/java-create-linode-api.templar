package synapticloop.linode;{\n}
{\n}
import java.io.IOException;{\n}
import java.util.ArrayList;{\n}
import java.util.List;{\n}
import java.util.Map;{\n}
import org.slf4j.Logger;{\n}
import org.slf4j.LoggerFactory;{\n}
{\n}
import org.apache.http.HttpStatus;{\n}
import org.apache.http.NameValuePair;{\n}
import org.apache.http.ParseException;{\n}
import org.apache.http.client.entity.UrlEncodedFormEntity;{\n}
import org.apache.http.client.methods.CloseableHttpResponse;{\n}
import org.apache.http.client.methods.HttpPost;{\n}
import org.apache.http.impl.client.CloseableHttpClient;{\n}
import org.apache.http.impl.client.HttpClients;{\n}
import org.apache.http.message.BasicNameValuePair;{\n}
import org.apache.http.util.EntityUtils;{\n}
import org.json.JSONArray;{\n}
import org.json.JSONException;{\n}
import org.json.JSONObject;{\n}
{\n}

import synapticloop.linode.exception.ApiException;{\n}
{\n}
import synapticloop.linode.api.request.*;{\n}
import synapticloop.linode.api.response.*;{\n}
{\n}

/**{\n}
 * The main class for interacting with the Linode api.{\n}
 * {\n}
 * @author synapticloop{\n}
 */{\n}
public class LinodeApi {{{\n}
{\t}	private static final Logger LOGGER = LoggerFactory.getLogger(LinodeApi.class);{\n}
{\n}
{\t}private static final String API_ENDPOINT = "https://api.linode.com/";{\n}
{\n}
{\t}private static final String PARAMETER_API_KEY = "api_key";{\n}
{\t}private static final String PARAMETER_API_ACTION = "api_action";{\n}
{\t}private static final String PARAMETER_API_REQUEST_ARRAY = "api_requestArray";{\n}
{\n}
{\t}private static final String PARAMETER_BATCH = "batch";{\n}
{\n}
{\t}private CloseableHttpClient closeableHttpClient = null;{\n}
{\n}
{\t}private String apiKey = null;{\n}
{\n}
{\t}private boolean debug = false;{\n}
{\n}
{\t}/**{\n}
{\t} * Create a Linode client with the specified API key{\n}
{\t} * {\n}
{\t} * @param apiKey the user's API key{\n}
{\t} */{\n}
{\t}public LinodeApi(String apiKey) {{{\n}
{\t}{\t}this(apiKey, false);{\n}
{\t}}{\n}
{\n}
{\t}/**{\n}
{\t} * Create a Linode client with specified API key and debug setting{\n}
{\t} * {\n}
{\t} * @param apiKey the user's API key{\n}
{\t} * @param debug true to enable request debugging, false otherwise{\n}
{\t} */{\n}
{\t}public LinodeApi(String apiKey, boolean debug) {{{\n}
{\t}{\t}this.apiKey = apiKey;{\n}
{\n}
{\t}{\t}this.closeableHttpClient = HttpClients.createDefault();{\n}
{\t}{\t}this.debug = debug;{\n}
{\t}}{\n}
{\n}
{\t}/**{\n}
{\t} * Execute a single request to the linode api{\n}
{\t} * {\n}
{\t} * @param linodeApiRequest the request to be made{\n}
{\t} * {\n}
{\t} * @return the response of the request{\n}
{\t} * {\n}
{\t} * @throws ApiException if there was a problem with the request{\n}
{\t} */{\n}
{\t}public LinodeApiResponse execute(LinodeApiRequest linodeApiRequest) throws ApiException {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}HttpPost httpPost = new HttpPost(API_ENDPOINT);{\n}
{\n}
{\t}{\t}{\t}ArrayList<NameValuePair> postParameters = new ArrayList<NameValuePair>();{\n}
{\t}{\t}{\t}postParameters.add(new BasicNameValuePair(PARAMETER_API_KEY, this.apiKey));{\n}
{\t}{\t}{\t}postParameters.add(new BasicNameValuePair(PARAMETER_API_ACTION, linodeApiRequest.getAction()));{\n}
{\n}
{\t}{\t}{\t}// now add the parameters{\n}
{\t}{\t}{\t}Map<String, String> parameters = linodeApiRequest.getParameters();{\n}
{\t}{\t}{\t}for (String parameterKey : parameters.keySet()) {{{\n}
{\t}{\t}{\t}{\t}postParameters.add(new BasicNameValuePair(parameterKey, parameters.get(parameterKey)));{\n}
{\t}{\t}{\t}}{\n}
{\t}{\t}{\t}{\n}
{\n}
{\t}{\t}{\t}String response = callApi(linodeApiRequest.getAction(), httpPost, postParameters);{\n}
{\n}
{\t}{\t}{\t}return(new LinodeApiResponse(new JSONObject(response)));{\n}
{\t}{\t}} catch (JSONException ex) {{{\n}
{\t}{\t}{\t}throw new ApiException(ex);{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}
{\t}/**{\n}
{\t} * Execute a batch request to the linode api.{\n}
{\t} * {\n}
{\t} * @param linodeApiRequests The list of requests to execute{\n}
{\t} * {\n}
{\t} * @return the list of responses to the requests{\n}
{\t} * {\n}
{\t} * @throws ApiException if there was an error with the request{\n}
{\t} */{\n}
{\t}public List<LinodeApiResponse> execute(List<LinodeApiRequest> linodeApiRequests) throws ApiException {{{\n}
{\t}{\t}List<LinodeApiResponse> linodeApiResponses = new ArrayList<LinodeApiResponse>();{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}HttpPost httpPost = new HttpPost(API_ENDPOINT);{\n}
{\n}
{\t}{\t}{\t}ArrayList<NameValuePair> postParameters = new ArrayList<NameValuePair>();{\n}
{\t}{\t}{\t}postParameters.add(new BasicNameValuePair(PARAMETER_API_KEY, this.apiKey));{\n}
{\t}{\t}{\t}postParameters.add(new BasicNameValuePair(PARAMETER_API_ACTION, PARAMETER_BATCH));{\n}
{\n}
{\t}{\t}{\t}// now add the parameters{\n}
{\t}{\t}{\t}JSONArray apiRequestArray = new JSONArray();{\n}
{\t}{\t}{\t}for (LinodeApiRequest linodeApiRequest : linodeApiRequests) {{{\n}
{\t}{\t}{\t}{\t}JSONObject jsonObject = new JSONObject();{\n}
{\n}
{\t}{\t}{\t}{\t}Map<String, String> parameters = linodeApiRequest.getParameters();{\n}
{\t}{\t}{\t}{\t}jsonObject.put(PARAMETER_API_ACTION, linodeApiRequest.getAction());{\n}
{\t}{\t}{\t}{\t}for (String parameterKey : parameters.keySet()) {{{\n}
{\t}{\t}{\t}{\t}{\t}jsonObject.append(parameterKey, parameters.get(parameterKey));{\n}
{\t}{\t}{\t}{\t}}{\n}
{\t}{\t}{\t}{\t}apiRequestArray.put(jsonObject);{\n}
{\t}{\t}{\t}}{\n}
{\n}
{\t}{\t}{\t}postParameters.add(new BasicNameValuePair(PARAMETER_API_REQUEST_ARRAY, apiRequestArray.toString()));{\n}
{\t}{\t}{\t}httpPost.setEntity(new UrlEncodedFormEntity(postParameters));{\n}
{\n}
{\t}{\t}{\t}String response = callApi(PARAMETER_BATCH, httpPost, postParameters);{\n}
{\n}
{\t}{\t}{\t}// as we are doing batch mode - the return will be an array{\n}
{\t}{\t}{\t}JSONArray jsonArray = new JSONArray(response);{\n}
{\t}{\t}{\t}for(int i = 0; i < jsonArray.length(); i ++) {{{\n}
{\t}{\t}{\t}{\t}linodeApiResponses.add(new LinodeApiResponse(jsonArray.getJSONObject(i)));{\n}
{\t}{\t}{\t}}{\n}
{\t}{\t}} catch (JSONException | IOException ex) {{{\n}
{\t}{\t}{\t}throw new ApiException(ex);{\n}
{\t}{\t}}{\n}
{\n}
{\t}{\t}return(linodeApiResponses);{\n}
{\t}}{\n}
{\n}
{\n}
{\t}/**{\n}
{\t} * Call the api{\n}
{\t} * {\n}
{\t} * @param action the action that was being called{\n}
{\t} * @param httpPost the http post object{\n}
{\t} * @param postParameters the post parameters for the httpPost{\n}
{\t} * {\n}
{\t} * @return The response{\n}
{\t} * {\n}
{\t} * @throws ApiException If there was an error with the call{\n}
{\t} */{\n}
{\t}private String callApi(String action, HttpPost httpPost, ArrayList<NameValuePair> postParameters) throws ApiException {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}httpPost.setEntity(new UrlEncodedFormEntity(postParameters));{\n}
{\t}{\t}{\t}CloseableHttpResponse httpResponse = closeableHttpClient.execute(httpPost);{\n}
{\t}{\t}{\t}int statusCode = httpResponse.getStatusLine().getStatusCode();{\n}
{\n}
{\t}{\t}{\t}throwIfUnsuccessful(action, statusCode);{\n}
{\n}
{\t}{\t}{\t}String response = null;{\n}
{\t}{\t}{\t}try {{{\n}
{\t}{\t}{\t}{\t}response = EntityUtils.toString(httpResponse.getEntity());{\n}
{\t}{\t}{\t}} catch (ParseException | IOException ex) {{{\n}
{\t}{\t}{\t}{\t}throw new ApiException(ex);{\n}
{\t}{\t}{\t}}{\n}
{\n}
{\t}{\t}{\t}if (debug) {{{\n}
{\t}{\t}{\t}{\t}if(LOGGER.isDebugEnabled()) {{{\n}
{\t}{\t}{\t}{\t}{\t}LOGGER.debug("Response for end point '{{}', with action '{{}': {{}", API_ENDPOINT, action, response);{\n}
{\t}{\t}{\t}{\t}}{\n}
{\t}{\t}{\t}}{\n}
{\t}{\t}{\t}return(response);{\n}
{\n}
{\t}{\t}} catch (IOException ex) {{{\n}
{\t}{\t}{\t}throw(new ApiException(ex));{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}
{\t}/**{\n}
{\t} * Throw an ApiException if the status code was not OK (200){\n}
{\t} * {\n}
{\t} * @param action The action that was done{\n}
{\t} * @param statusCode The response status code{\n}
{\t} * {\n}
{\t} * @throws ApiException if the response code was not OK (200){\n}
{\t} */{\n}
{\t}private void throwIfUnsuccessful(String action, int statusCode) throws ApiException {{{\n}
{\t}{\t}if (statusCode != HttpStatus.SC_OK) {{{\n}
{\t}{\t}{\t}StringBuilder stringBuilder = new StringBuilder();{\n}
{\t}{\t}{\t}stringBuilder.append("Non-200 HTTP Status code returned:");{\n}
{\t}{\t}{\t}stringBuilder.append(statusCode);{\n}
{\t}{\t}{\t}stringBuilder.append(" for action '");{\n}
{\t}{\t}{\t}stringBuilder.append(action);{\n}
{\t}{\t}{\t}stringBuilder.append("'.");{\n}
{\t}{\t}{\t}throw new ApiException(stringBuilder.toString());{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}
{--
	now for all of the api calls
}
{loop apis as api}
	{loop api.apiMethods as apiMethod}
		{\t}/**{\n}

		{loop apiMethod.descriptions as description}
			{\t} * {description}{\n}
		{endloop}

		{\t} *{\n}
			{loop apiMethod.apiErrors as apiError}
				{if apiErrorStatus.first}
					{\t} * {\n}
					{\t} * Possible return error codes:{\n}
					{\t} * {\n}
					{\t} * <ul>{\n}
				{endif}
				{\t} *   <li>{apiError}</li>{\n}
				{if apiErrorStatus.last}
					{\t} * </ul>{\n}
				{endif}
			{endloop}
			{--
			  At this point we are doing a special test for the 'echo' method
			}

			{if fn:=[apiMethod.name, "echo"]}
				{\t} * @param parameters the map of parameters (String:String) to echo back{\n}
			{endif}

			{loop apiMethod.requiredApiMethodParams as apiMethodParam}
				{\t} * @param {apiMethodParam.parameterName}
					{if apiMethodParam.required} <strong>(REQUIRED)</strong> {else} <em>(OPTIONAL)</em> {endif}
					{if fn:=[fn:length[apiMethodParam.description], "0"]}
						(<strong>SORRY</strong> - there was no description provided in the documentation)
					{else}  {apiMethodParam.description}{endif}{\n}
			{endloop}
		{\t} *{\n}
		{\t} * @return the parsed {api.classname}{apiMethod.responseName}Response response object{\n}
		{\t} *{\n}
		{\t} * @throws ApiException if a required parameter is null, or there was an error with the call{\n}
		{\t} */{\n}

		{\t}public {api.classname}{apiMethod.responseName}Response get{api.classname}{apiMethod.upperName}(

				{loop apiMethod.requiredApiMethodParams as apiMethodParam}
					{apiMethodParam.type} {apiMethodParam.parameterName}{if !apiMethodParamStatus.last}, {endif}
				{endloop}

				{if fn:=[apiMethod.name, "echo"]}Map<String, String> parameters{endif}

					) throws ApiException {{{\n}

		{\t}{\t}return(new {api.classname}{apiMethod.responseName}Response(execute({api.classname}Request.{apiMethod.name}(
				{if fn:=[apiMethod.name, "echo"]}
					parameters
				{else}
					{loop apiMethod.requiredApiMethodParams as apiMethodParam}
						{apiMethodParam.parameterName}
						{if !apiMethodParamStatus.last}, {endif}
					{endloop}
				{endif}

		)).getJSON()));{\n}
		{\t}}{\n}
		{\n}

		{if !fn:=[fn:length[apiMethod.requiredApiMethodParams], fn:length[apiMethod.apiMethodParams]]}

			{\t}/**{\n}

			{loop apiMethod.descriptions as description}
				{\t} * {description}{\n}
			{endloop}


			{loop apiMethod.apiErrors as apiError}
				{if apiErrorStatus.first}
					{\t} * {\n}
					{\t} * Possible return error codes:{\n}
					{\t} * {\n}
					{\t} * <ul>{\n}
				{endif}
				{\t} *   <li>{apiError}</li>{\n}
				{if apiErrorStatus.last}
					{\t} * </ul>{\n}
				{endif}
			{endloop}

			{\t} *{\n}
			{--
			  At this point we are doind a special test for the 'echo' method
			}

			{if fn:=[apiMethod.name, "echo"]}
				{\t} * @param parameters the map of parameters (String:String) to echo back{\n}
			{endif}

				{loop apiMethod.apiMethodParams as apiMethodParam}
					{\t} * @param {apiMethodParam.parameterName} 
						{if apiMethodParam.required}<strong>(REQUIRED)</strong> {else} <em>(OPTIONAL)</em> {endif}
						{if fn:=[fn:length[apiMethodParam.description], "0"]}
							(<strong>SORRY</strong> - there was no description provided in the documentation)
						{else}
							{apiMethodParam.description}
						{endif}{\n}
				{endloop}
			{\t} *{\n}
			{\t} * @return the parsed {api.classname}{apiMethod.responseName}Response response object{\n}
			{\t} *{\n}
			{\t} * @throws ApiException if a required parameter is null, or there is an error with the call{\n}
			{\t} */{\n}

			{\t}public {api.classname}{apiMethod.responseName}Response get{api.classname}{apiMethod.upperName}(
				{loop apiMethod.apiMethodParams as apiMethodParam}
					{apiMethodParam.type} {apiMethodParam.parameterName}{if !apiMethodParamStatus.last}, {endif}
				{endloop}

				{if fn:=[apiMethod.name, "echo"]}Map<String, String> parameters{endif}

					) throws ApiException {{{\n}

		{\t}{\t}return(new {api.classname}{apiMethod.responseName}Response(execute({api.classname}Request.{apiMethod.name}(
				{if fn:=[apiMethod.name, "echo"]}
					parameters
				{else}
					{loop apiMethod.apiMethodParams as apiMethodParam}
						{apiMethodParam.parameterName}
						{if !apiMethodParamStatus.last}, {endif}
					{endloop}
				{endif}

				)).getJSON()));{\n}

		{\t}}{\n}

{\n}

		{endif}
	{endloop}


{endloop}
}{\n}